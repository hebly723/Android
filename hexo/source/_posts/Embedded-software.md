---
title: 嵌入式软件
tags:
  - 复习
date: 2017-06-28 21:25:58
---


按老师给的提纲列的复习资料

<!-- more -->

# 第一章

## 定义

目前，对嵌入式系统的定义多种多样，但没有一种定义是全面的。下面给出两种比较合理定义： 

* 
从技术的角度定义：以应用为中心、以计算机技术为基础、软件硬件可裁剪、适应应用系统对功能、可靠性、成本、体积、功耗严格要求的专用计算机系统。

* 
从系统的角度定义：嵌入式系统是设计完成复杂功能的硬件和软件，并使其紧密耦合在一起的计算机系统。术语嵌入式反映了这些系统通常是更大系统中的一个完整的部分，称为嵌入的系统。嵌入的系统中可以共存多个嵌入式系统。


## 特点

### 实时操作系统的特点

* 异步的事件响应 

* 切换时间和中断延迟时间确定 

* 优先级中断和调度 

* 抢占式调度 

* 内存锁定 

* 连续文件 

* 同步 

总的来说实时操作系统是事件驱动的，能对来自外界的作用和信号在限定的时间范围内作出响应。它强调的是实时性、可靠性和灵活性, 与实时应用软件相结合成为有机的整体起着核心作用, 由它来管理和协调各项工作,为应用软件提供良好的运行软件环境及开发环境。

从实时系统的应用特点来看实时操作系统可以分为两种：一般实时操作系统和嵌入式实时操作系统

一般实时操作系统应用于实时处理系统的上位机和实时查询系统等实时性较弱的实时系统，并且提供了开发、调试、运用一致的环境。 

嵌入式实时操作系统应用于实时性要求高的实时控制系统，而且应用程序的开发过程是通过交叉开发来完成的，即开发环境与运行环境是不一致。嵌入式实时操作系统具有规模小(一般在几K～几十K 内)、可固化使用实时性强(在毫秒或微秒数量级上)的特点 。

## 开发特点

## 分类

### 嵌入式处理器大致分类：

* 注重嵌入式处理器的尺寸、能耗和价格。应用于PDA等不注重计算的设备；

* 注重嵌入式处理器的性能。应用于路由器等计算密集型的设备；

* 注重嵌入式处理器的性能、尺寸、能耗和价格。应用于蜂窝电话等设备；

### 嵌入式处理器分类：

* 嵌入式微处理器；

* 嵌入式微控制器；

* 嵌入式DSP处理器；

* 嵌入式片上系统（SOC）

## 前后台系统

### 概念

对基于芯片的开发来说，应用程序一般是一个无限的循环，可称为前后台系统或超循环系统。

很多基于微处理器的产品采用前后台系统设计，例如微波炉、电话机、玩具等。在另外一些基于微处理器应用中，从省电的角度出发，平时微处理器处在停机状态，所有事都靠中断服务来完成。

![前后台系统](/images/background system.png)

循环中调用相应的函数完成相应的操作，这部分可以看成后台行为，后台也可以叫做任务级。这种系统在处理的及时性上比实际可以做到的要差。 

中断服务程序处理异步事件，这部分可以看成前台行为，前台也叫中断级。时间相关性很强的关键操作一定是靠中断服务程序来保证的。

# 第二章

## 嵌入式系统工程设计方法

### 由上而下与由下而上

#### 概念

由上而下是一个正统的设计方式，也就是说，所有的设计皆是遵循系统工程的流程来进行。相对而言，由下而上表示一个系统是由已经有的基础（或组件）为起点，开始往上延伸，最后将系统完成。

![前后台系统](/images/up and down.png)  

### UML系统建模

#### 概念

UML（Unified Modeling Language）是一种原本设计用来描述对象导向程序语言开发的图形化语言。由于它具有描述事物的多重性，所以理论上也可以被拉到其他领域使用。
在实际使用上，根据不同的使用情况，UML提供了不同的图形来描述系统。在UML中，包括了下面几种图形：类图、状态图、对象图、用例图、顺序图、协作图、活动图、组件图和部署图。

#### 优点

语言的用处在于沟通。UML也是一种语言，它利用视觉化的方法来制定、构建以及记录对象导向系统。因此，可以把UML当作一种软件工程用的语言。
使用UML的好处在于可以在短时间内了解别人要传达的消息，而不是花时间在了解消息本身如何解读。UML提供给用户基础的工具与基本的规范，在这个基础上，用户可以利用这个语言去描述他所想要描述的系统，用不同的界面去描绘出系统的不同方面。

### 面向对象OO的思想

#### 概念

随着系统的需求日益增加，系统的功能及复杂程度不断增大，为了使系统开发变得容易，我们要逐步改进我们对系统的思考方式以及我们开发系统的的方式，这项新技术我们称之为面向对象的的开发。
传统的结构化方法是将系统分解为很多基本函数的集合，数据被孤立分离，并且不考虑并发。而面向对象方法的基本分解单位为对象。在面对较复杂的系统设计时，我们可以将它作为一个对象来进行分析。同样，这个对象也可以分解为多个对象，多个对象各司其职，相互协作以完成目标。

# 第三章

（1-8）

## Arm处理器状态

ARM7TDMI处理器内核使用V4T版本的ARM结构，该结构包含32位ARM指令集和16位Thumb指令集。因此ARM7TDMI处理器有两种操作状态：

* ARM状态：32位，这种状态下执行的是字方式的ARM指令；

* Thumb状态：16位，这种状态下执行半字方式的Thumb指令。

注意：两个状态之间的切换并不影响处理器模式或寄存器内容。

使用BX指令将ARM7TDMI内核的操作状态在ARM状态和Thumb状态之间进行切换（详见第4章） ，程序如下所示。

![处理器状态](/images/Processor State.png)

## 处理器模式

### 简介

ARM体系结构支持7种处理器模式，分别为：用户模式、快中断模式、中断模式、管理模式、中止模式、未定义模式和系统模式，如下表所示。这样的好处是可以更好的支持操作系统并提高工作效率。ARM7TDMI完全支持这七种模式。

![处理器模式](/images/processor_mode.png)

### 特权模式

除用户模式外，其它模式均为特权模式。ARM内部寄存器和一些片内外设在硬件设计上只允许（或者可选为只允许）特权模式下访问。此外，特权模式可以自由的切换处理器模式，而用户模式不能直接切换到别的模式。

### 异常模式

快中断， 中断， 管理， 中止，未定义这五种模式称为异常模式。它们除了可以通过程序切换进入外，也可以由特定的异常进入。当特定的异常出现时，处理器进入相应的模式。每种异常模式都有一些独立的寄存器，以避免异常退出时用户模式的状态不可靠。

### 用户和系统模式

这两种模式都不能由异常进入，而且它们使用完全相同的寄存器组。
系统模式是特权模式，不受用户模式的限制。操作系统在该模式下访问用户模式的寄存器就比较方便，而且操作系统的一些特权任务可以使用这个模式访问一些受控的资源。

## 内部寄存器对软件有什么特点/支持作用

空

### 特点

在ARM7TDMI处理器内部有37个用户可见的寄存器。
在不同的工作模式和处理器状态下，程序员可以访问的寄存器也不尽相同。

所有的37个寄存器，分成两大类：
31个通用32位寄存器；
6个状态寄存器。

![各种状态下的通用寄存器](/images/processor-mode.png)

在汇编语言中寄存器R0～R13为保存数据或地址值的通用寄存器。它们是完全通用的寄存器，不会被体系结构作为特殊用途，并且可用于任何使用通用寄存器的指令。

其中R0～R7为未分组的寄存器，也就是说对于任何处理器模式，这些寄存器都对应于相同的32位物理寄存器。

寄存器R8～R14为分组寄存器。它们所对应的物理寄存器取决于当前的处理器模式，几乎所有允许使用通用寄存器的指令都允许使用分组寄存器

寄存器R8～R12有两个分组的物理寄存器。一个用于除FIQ模式之外的所有寄存器模式，另一个用于FIQ模式。这样在发生FIQ中断后，可以加速FIQ的处理速度。

寄存器R13、R14分别有6个分组的物理寄存器。一个用于用户和系统模式，其余5个分别用于5种异常模式。

寄存器R13常作为堆栈指针（SP）。在ARM指令集当中，没有以特殊方式使用R13的指令或其它功能，只是习惯上都这样使用。但是在Thumb指令集中存在使用R13的指令。

R14为链接寄存器（LR），在结构上有两个特殊功能：
在每种模式下，模式自身的R14版本用于保存子程序返回地址；
当发生异常时，将R14对应的异常模式版本设置为异常返回地址（有些异常有一个小的固定偏移量）。


## FIQ速度快的原因

寄存器R8～R12有两个分组的物理寄存器。一个用于除FIQ模式之外的所有寄存器模式，另一个用于FIQ模式。这样在发生FIQ中断后，可以加速FIQ的处理速度。

## 什么是内核的异常

### 概念

只要正常的程序流被暂时中止，处理器就进入异常模式。例如响应一个来自外设的中断。在处理异常之前，ARM7TDMI内核保存当前的处理器状态，这样当处理程序结束时可以恢复执行原来的程序。
如果同时发生两个或更多异常，那么将按照固定的顺序来处理异常。

## ARM有几级流水线

三级流水线

* 取指从存储器装载一条指令

* 译码识别将要被执行的指令

* 执行处理指令并将结果写会寄存器

## 大端小端模式

### 简介

ARM7TDMI处理器可以将存储器中的字以下列格式存储

* 大端格式（Big-endian）

* 小端格式（Little-endian）

### 地址空间

ARM结构使用单个平面的232个8位字节地址空间。字节地址按照无符号数排列，从0到232－1。地址空间可以看作是包含230个32位字，或231个16位半字。如果地址向上或向下溢出地址空间，通常会发生翻转。

注意：如果在取指操作时地址发生溢出，只要没有执行预取的无效指令，就不会导致异常。

跳转目标的计算方法：
(当前指令的地址) + 8 + 偏移量
下一条指令位置的计算方法：
(当前指令的地址) + 4  

### 地址空间的规则

* 位于地址A的字包含的字节位于地址A,A+1,A+2和A+3；

* 位于地址A的半字包含的字节位于地址A和A+1；

* 位于地址A+2的半字包含的字节位于地址A+2和A+3；

* 位于地址A的字包含的半字位于地址A和A+2； 

![存储器格式](/images/embedded_software/IO_mode.png)

### 两种映射机制

存储器系统有两种映射机制

#### 小端存储器系统：

在小端格式中，高位数字存放在高位字节中。因此存储器系统字节0连接到数据线7～0。 

#### 大端存储器系统：

在大端格式中，高位数字存放在低位字节中。因此存储器系统字节0连接到数据线31～24。 

![存储器格式](/images/embedded_software/IOMapper.png)

一个基于ARM内核的芯片可以只支持大端模式或小端模式，也可以两者都支持。
在ARM指令集中不包含任何直接选择大小端的指令，但是一个同时支持大小端模式的ARM芯片可以通过硬件配置（一般使用芯片的引脚来配置）来匹配存储器系统所使用的规则。

注意：如果实际的存储器格式与芯片的存储器格式不符时，只有以字为单位的数据存取才正确，否则将出现不可预期的结果。

## ARM支持的堆栈种类

### Full descending 满递减堆栈——FD

堆栈首部是高地址，堆栈向低地址增长。栈指针总是指向堆栈最后一个元素（最后一个元素是最后压入的数据）。

ARM-Thumb过程调用标准和ARM、Thumb C/C++ 编译器总是使用Full descending 类型堆栈。

### ◎ Full ascending 满递增堆栈——FA

堆栈首部是低地址，堆栈向高地址增长。栈指针总是指向堆栈最后一个元素（最后一个元素是最后压入的数据）。

### ◎ Empty descending 空递减堆栈——ED

堆栈首部是高地址，堆栈向低地址增长。栈指针总是指向下一个将要放入数据的空位置。

### ◎ Empty ascending 空递增堆栈——EA

堆栈首部是低地址，堆栈向高地址增长。栈指针总是指向下一个将要放入数据的空位置。

## 一个处理器一般有几个指令集

ARM7TDMI处理器有两个指令集，每种指令集都有自己的优缺点：

* 32位ARM指令集 ：对ARM核的特性提供最大的支持，具有高效、快速的特点；

* 16位Thumb指令集：它是ARM指令的子集，具有更高的代码密度，非常适合存储器带宽和空间都受限制的嵌入式应用场合。

# 第四章

ARM的指令集（给指令讲作用（+s， +eq））

![arm的简单程序](/images/embedded_software/simpleArmProgram.png)

## 指令格式

ARM指令的基本格式如下：

```
<opcode> {<cond>} {S}    <Rd> ,<Rn>{,<operand2>} 
```
其中<>号内的项是必须的，{}号内的项是可选的。各项的说明如下：

* opcode：指令助记符；	

* cond：执行条件；

* S：是否影响CPSR寄存器的值；

* Rd：目标寄存器；		 

* Rn：第1个操作数的寄存器；

* operand2：第2个操作数；

## 第二个操作数

灵活的使用第2个操作数“operand2”能够提高代码效率。它有如下的形式：

### #immed_8r——常数表达式；

该常数必须对应8位位图，即一个8位的常数通过循环右移偶数位得到。

例如：
MOV	R0,#1
AND	R1,R2,#0x0F

![#immed_8r常数表达式](/images/embedded_software/immed_8r.png)

### Rm——寄存器方式；

在寄存器方式下，操作数即为寄存器的数值。
例如：
SUB	R1,R1,R2
MOV	PC,R0

### Rm,shift——寄存器移位方式；

将寄存器的移位结果作为操作数，但Rm值保持不变，移位方法如下：

![寄存器移位](/images/embedded_software/rmShift.png)

![寄存器移位](/images/embedded_software/secondVariable.png)

例如：
ADD	R1,R1,R1,LSL #3	;R1=R1+R1*8=9R1
SUB	R1,R1,R2,LSR R3	;R1=R1-(R2/2R3)

## 条件码

使用条件码“cond”可以实现高效的逻辑操作，提高代码效率。

所有的ARM指令都可以条件执行，而Thumb指令只有B（跳转）指令具有条件执行 功能。如果指令不标明条件代码，将默认为无条件（AL）执行。

### 指令条件码表

![指令条件码表](/images/embedded_software/instructions_table.png)

示例：

C代码：
If(a > b)
	a++;
Else
	b++;

对应的汇编代码：

CMP	R0,R1	    ;R0与R1比较
ADDHI	R0,R0,#1  ;若R0>R1，则R0=R0+1
ADDLS	R1,R1,#1  ;若R0≤1，则R1=R1+1

## 存储器访问指令

ARM处理器是典型的RISC处理器，对存储器的访问只能使用加载和存储指令实现。ARM处理器是冯•诺依曼存储结构，程序空间、RAM空间及I/O映射空间统一编址，除对RAM操作以外，对外围IO、程序数据的访问均要通过加载/存储指令进行。
存储器访问指令分为单寄存器操作指令和多寄存器操作指令。

### 单寄存器加载

![单寄存器加载](/images/embedded_software/Single_register.png)

### 单寄存器存储

![单寄存器存储](/images/embedded_software/registermemory.png)

LDR/STR指令用于对内存变量的访问、内存缓冲区数据的访问、查表、外围部件的控制操作等。若使用LDR指令加载数据到PC寄存器，则实现程序跳转功能，这样也就实现了程序散转。

所有单寄存器加载/存储指令可分为“字和无符号字节加载存储指令”和“半字和有符号字节加载存储指令。

#### LDR和STR——字和无符号字节加载/存储指令

LDR指令用于从内存中读取单一字或字节数据存入寄存器中，STR指令用于将寄存器中的单一字或字节数据保存到内存。指令格式如下：

  LDR{cond}{T}	Rd,<地址>  ;将指定地址上的字数据读入Rd
  STR{cond}{T}	Rd,<地址>  ;将Rd中的字数据存入指定地址
  LDR{cond}B{T}	Rd,<地址>  ;将指定地址上的字节数据读入Rd
  STR{cond}B{T}	Rd,<地址>  ;将Rd中的字节数据存入指定地址

其中，T为可选后缀。若指令有T，那么即使处理器是在特权模式下，存储系统也将访问看成是在用户模式下进行的。T在用户模式下无效，不能与前索引偏移一起使用T。 

![LDR和STR](/images/embedded_software/LDR和STR.png)

LDR/STR指令寻址非常灵活，它由两部分组成，其中一部分为一个基址寄存器，可以为任一个通用寄存器；另一部分为一个地址偏移量。地址偏移量有以下3种格式： 

* 立即数。立即数可以是一个无符号的数值。这个数据可以加到基址寄存器，也可以从基址寄存器中减去这个数值。 如：LDR  R1,[R0,#0x12] 

* 寄存器。寄存器中的数值可以加到基址寄存器，也可以从基址寄存器中减去这个数值。如：LDR  R1,[R0,R2] 

* 寄存器及移位常数。寄存器移位后的值可以加到基址寄存器，也可以从基址寄存器中减去这个数值。 如：LDR  R1,[R0,R2,LSL #2]	 

从寻址方式的地址计算方法分，加载/存储指令有以下4种格式： 

* 零偏移。			如：LDR  Rd,[Rn] 

* 前索引偏移。		如：LDR  Rd,[Rn,#0x04]!

* 程序相对偏移。	如：LDR  Rd,labe1	 

* 后索引偏移。		如：LDR  Rd,[Rn],#0x04

注意：大多数情况下，必须保证字数据操作的地址是32位对齐的。

#### LDR和STR——半字和有符号字节加载/存储指令

这类LDR/STR指令可加载有符号半字或字节，可加载/存储无符号半字。偏移量格式、寻址方式与加载/存储字和无符号字节指令相同。 

## 数据处理指令

## 乘法指令

## ARM分支指令

## 协处理器指令

## 杂项指令

## 伪指令

# 第六章

## 最小系统

### 概念

一个嵌入式处理器自己是不能独立工作的，必须给它供电、加上时钟信号、提供复位信号，如果芯片没有片内程序存储器，则还要加上存储器系统，然后嵌入式处理器芯片才可能工作。这些提供嵌入式处理器运行所必须的条件的电路与嵌入式处理器共同构成了这个嵌入式处理器的最小系统。而大多数基于ARM7处理器核的微控制器都有调试接口，这部分在芯片实际工作时不是必需的，但因为这部分在开发时很重要，所以也把这部分也归入最小系统中。 

### 组成部分

![最小系统的组成部分](/images/embedded_software/smallest_system.png)

#### 电源

电源系统为整个系统提供能量，是整个系统工作的基础，具有极其重要的地位，但却往往被忽略。如果电源系统处理得好，整个系统的故障往往减少了一大半。

#### 时钟

目前所有的微控制器均为时序电路，需要一个时钟信号才能工作，大多数微控制器具有晶体振荡器。简单的方法是利用微控制器内部的晶体振荡器，但有些场合（如减少功耗、需要严格同步等情况）需要使用外部振荡源提供时钟信号。 

![时钟](/images/embedded_software/LPC2000_timer.png)

#### 复位及其芯片配置

微控制器在上电时状态并不确定，这造成微控制器不能正确工作。为解决这个问题，所有微控制器均有一个复位逻辑，它负责将微控制器初始化为某个确定的状态。这个复位逻辑需要一个复位信号才能工作。一些微控制器自己在上电时会产生复位信号，但大多数微控制器需要外部输入这个信号。这个信号的稳定性和可靠性对微控制器的正常工作有重大影响。 

复位电路可以使用简单的阻容复位，这个电路成本低廉，但不能保证任何情况产生稳定可靠的复位信号，所以一般场合需要使用专门的复位芯片。 

#### 存储器系统

对于大部分微控制器来说，存储器系统不是必需的，但如果微控制器没有片内程序存储器或数据存储器时，就必须设计存储器系统，这一般通过微控制器的外部总线接口实现。

#### 调试与测试接口

调试与测试接口不是系统运行必须的，但现代系统越来越强调可测性，调试、测试接口的设计也要重视了。LPC2000有一个内置JTAG调试接口，通过这个接口可以控制芯片的运行并获取内部信息。 

# 第七章

软件移植，都需要做哪些工作

移植的主要工作就是编写这些与处理器硬件相关的代码。

在移植前针对所使用的微处理器进行规划，主要有以下几个方面的考虑：编译器的选择、任务模式的选择和支持的指令集。

使用ADS编译程序和调试。

ARM7处理器核具有用户、系统、管理、中止、未定义、中断和快中断七种模式，其中除用户模式外其它均为特权模式。其中管理、中止、未定义、中断和快中断模式与相应异常相联系，任务使用这些模式不太适合。而系统模式除了是特权模式外，其它与用户模式一样，因而可选为任务使用的模式只有用户模式和系统模式。为了尽量减少任务代码错误对整个程序的影响，缺省的任务模式定为用户模式，可选为系统模式，同时提供接口使任务可以在这两种模式间切换。

带T变量的ARM7处理器核具有两个指令集（可以参考第3章  ）：标准32位ARM指令集和16位Thumb指令集，两种指令集有不同的应用范围。为了最大限度地支持芯片的特性，任务应当可以使用任意一个指令集并可以自由切换，而且不同的任务应当可以使用不同的指令集，这次移植的代码已经实现了这一点。 

要移植一个操作系统到一个特定的CPU体系结构上并不是一件很容易的事情，它对移植者有以下要求：
1． 对目标体系结构要有很深了解；
2． 对OS原理要有较深入的了解；
3． 对所使用的编译器要有较深入的了解；
4． 对需要移植的操作系统要有相当的了解；
5． 对具体使用的芯片也要一定的了解。

移植需要编写的文件

在具体的项目中应用移植代码时，还需要做一些工作，这是因为：

1．各种基于ARM7处理器核的芯片的硬件结构不尽相同，所以需要编写部分启动代码（参看第5章）。另外中断服务程序的编写方法也各不相同；

2.因为各个项目对资源的要求不一样，所以尽管使用同一系列的芯片，其时钟节拍中断也可能使用不同的中断实现。 

将μC/OS-II移植到LPC2000时，需要完成的工作主要有以下几个部分：

 编写或获取启动代码；
 挂接SWI软件中断；
 中断及时钟节拍中断；
 编写应用程序。

# 第八章

## 平台

### 概念

平台是一个意义很广泛的词，要准确的定义平台不是件容易的事。在嵌入式系统中的开发平台具有如下特点：

#### 层次性

层次性首先表现在平台本身具有层次，高层的平台是以低层平台为基础搭建起来的。还表现在每个层次的平台的内部还有层次性。越高层次的平台越容易使用，对使用者的要求也就越低。

#### 服务性

平台是为应用服务的，没有应用的平台是无意义的，没有存在的必要。对于元器件来说，线路板就是它的应用。而API是硬件平台的应用，应用程序又是API的应用。

#### 规范性

当一个平台建立起来后，其对应用的接口就具有一定的规范。一个软件模块一旦开发完毕，其接口函数及使用方法就确定了，应用程序就需要按照规范使用。

#### 通用性

平台从来不是给一个应用使用的。如果一个平台只能给一个应用使用，作为平台来说，其设计是失败的（尽管其作为最终应用可能是成功的）。这是平台的服务性决定的。 

#### 技术密度 

平台特别是商业平台通常由相关领域的专家建立。这是因为往往需要适应不同的应用的要求，所以其需要的技术含量是很高的。

### 优势。

应用程序接口这个嵌入式软件开发平台的提出和应用是因为其能够解决当前及今后的嵌入式开发过程中出现的一些矛盾。以下是使用嵌入式软件开发平台（API）开发的优点： 
缩短开发时间
降低对开发人员的要求
降低开发成本
增加稳定性和可靠性
降低软件对硬件变化的敏感性
